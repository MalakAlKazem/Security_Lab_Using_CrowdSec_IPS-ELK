input {
  beats { port => 5044 }
}

filter {
  if [log_source] == "openresty" and !("crowdsec_decisions" in [tags]) {

    grok {
      match => {
        "message" => '%{IPORHOST:[source][ip]} %{DATA:[nginx][access][user_name]} %{DATA:[nginx][access][remote_user]} \[%{HTTPDATE:[nginx][access][time]}\] "%{WORD:[http][request][method]} %{URIPATHPARAM:[url][original]} HTTP/%{NUMBER:[http][version]}" %{NUMBER:[http][response][status_code]:int} %{NUMBER:[http][response][body][bytes]:int} "%{DATA:[http][request][referrer]}" "%{DATA:[user_agent][original]}"'
      }
    }

    date {
      match  => [ "[nginx][access][time]", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
    }

    mutate {
      copy => { "[url][original]" => "[url][full]" }
      add_tag => [ "nginx_access_parsed" ]
      remove_field => [ "[nginx][access][time]" ]
    }

    # Split only if we have a query string
    if [url][original] =~ "\?" {
      dissect {
        mapping => { "[url][original]" => "%{[url][path]}?%{[url][query]}" }
        add_tag => [ "url_has_query" ]
        tag_on_failure => []   # prevents _dissectfailure
      }
    } else {
      mutate { copy => { "[url][original]" => "[url][path]" } }
    }
  }
}

output {
  if !("crowdsec_decisions" in [tags]) {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "nginx-logs-%{+YYYY.MM.dd}"
    }
  }
}
